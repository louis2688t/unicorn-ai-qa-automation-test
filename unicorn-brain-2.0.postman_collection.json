{
	"info": {
		"_postman_id": "18ab6263-41a3-46bf-9a44-9f8effc65c2e",
		"name": "unicorn-brain/2.0",
		"schema": "https://schema.getpostman.com/json/collection/v2.0.0/collection.json",
		"_exporter_id": "29850155"
	},
	"item": [
		{
			"name": "/vectordb/collection",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"// // Define the OAuth 2.0 token request parameters\r",
							"// const tokenUrl = pm.environment.get('access_token_url');\r",
							"// const clientId = pm.environment.get('client_id');\r",
							"// const clientSecret = pm.environment.get('client_secret');\r",
							"// const scope = pm.environment.get('scope');\r",
							"\r",
							"// pm.sendRequest({\r",
							"//     url: tokenUrl,\r",
							"//     method: \"POST\",\r",
							"//     header: [\r",
							"//         'Content-Type:application/x-www-form-urlencoded'\r",
							"//     ],\r",
							"//     body: {\r",
							"//         mode: \"urlencoded\",\r",
							"//         urlencoded: [\r",
							"//             {key: \"client_id\", value: clientId},\r",
							"//             {key: \"client_secret\", value: clientSecret},\r",
							"//             {key: \"scope\", value: scope},\r",
							"//             {key: \"grant_type\", value: \"client_credentials\"}\r",
							"//         ]\r",
							"//     },\r",
							"// },\r",
							"// (error, response) => {    \r",
							"//     pm.environment.set(\"access_token\", response.json().access_token);    \r",
							"// });"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Array is not empty\", function () {\r",
							"    pm.expect(pm.response.json().length).to.be.above(0);\r",
							"});\r",
							"\r",
							"pm.test(\"No duplicate values in array\", function () {\r",
							"    const array = pm.response.json();\r",
							"    const set = new Set(array);\r",
							"    pm.expect(array.length).to.eql(set.size);\r",
							"});\r",
							"\r",
							"pm.test(\"All values are strings\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(typeof item).to.eql('string');\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"No empty strings in array\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(item).to.not.eql('');\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"No null or undefined values in array\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(item).to.not.be.null;\r",
							"        pm.expect(item).to.not.be.undefined;\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Specific number of strings with suffix\", function () {\r",
							"    const array = pm.response.json();\r",
							"    const suffixCount = array.filter(item => item.endsWith('suffix')).length; // replace 'suffix' with actual suffix\r",
							"    pm.expect(suffixCount).to.eql(3)\r",
							"});\r",
							"\r",
							"pm.test(\"No prohibited special characters in strings\", function () {\r",
							"    const prohibitedChars = ['%', '$', '#']; \r",
							"    pm.response.json().forEach(item => {\r",
							"        prohibitedChars.forEach(char => {\r",
							"            pm.expect(item.includes(char)).to.be.false;\r",
							"        });\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Strings with numbers have them in expected format\", function () {\r",
							"    const numberPattern = /\\d{4}_\\d{2}_\\d{2}_\\d{4}/;\r",
							"    pm.response.json().forEach(item => {\r",
							"        if (item.match(/\\d/)) { // if string contains a number\r",
							"            pm.expect(numberPattern.test(item)).to.be.true;\r",
							"        }\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"No whitespace characters in strings\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(/\\s/.test(item)).to.be.false;\r",
							"    });\r",
							"});\r",
							"\r",
							"{\r",
							"  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
							"  \"type\": \"array\",\r",
							"  \"items\": {\r",
							"    \"type\": \"string\",\r",
							"    \"pattern\": \"^[a-zA-Z0-9_]+$\"\r",
							"  },\r",
							"  \"uniqueItems\": true,\r",
							"  \"minItems\": 1\r",
							"}\r",
							"\r",
							"const tv4 = require('tv4');\r",
							"\r",
							"const schema = {\r",
							"  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
							"  \"type\": \"array\",\r",
							"  \"items\": {\r",
							"    \"type\": \"string\",\r",
							"    \"pattern\": \"^[a-zA-Z0-9_]+$\"\r",
							"  },\r",
							"  \"uniqueItems\": true,\r",
							"  \"minItems\": 1\r",
							"};\r",
							"\r",
							"pm.test('Schema is valid', function() {\r",
							"    const response = pm.response.json();\r",
							"    const validationResult = tv4.validateResult(response, schema);\r",
							"    pm.expect(validationResult.valid).to.be.true;\r",
							"    if (!validationResult.valid) {\r",
							"        console.log(validationResult.errors);\r",
							"    }\r",
							"});\r",
							"\r",
							"pm.test(\"Array is not empty\", function () {\r",
							"    pm.expect(pm.response.json().length).to.be.above(0);\r",
							"});\r",
							"\r",
							"pm.test(\"No duplicate values in array\", function () {\r",
							"    const array = pm.response.json();\r",
							"    const set = new Set(array);\r",
							"    pm.expect(array.length).to.eql(set.size);\r",
							"});\r",
							"\r",
							"pm.test(\"Specific string is present\", function () {\r",
							"    pm.expect(pm.response.json()).to.include('specific_string');\r",
							"});\r",
							"\r",
							"pm.test(\"No string exceeds maximum length\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(item.length).to.be.below(256);\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"No string is below minimum length\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(item.length).to.be.above(1);\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"All strings are in lowercase\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(item).to.eql(item.toLowerCase());\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Specific number of strings have prefix\", function () {\r",
							"    const array = pm.response.json();\r",
							"    const prefixCount = array.filter(item => item.startsWith('prefix')).length;\r",
							"    pm.expect(prefixCount).to.eql(3);\r",
							"});\r",
							"\r",
							"pm.test(\"All strings are alphanumeric\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(/^[a-z0-9]+$/i.test(item)).to.be.true;\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"No strings have repeating consecutive characters\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(/(.)\\1/.test(item)).to.be.false;\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Array is not empty after filtering\", function () {\r",
							"    const array = pm.response.json().filter(item => item.includes('substring'));\r",
							"    pm.expect(array.length).to.be.above(0);\r",
							"});\r",
							"\r",
							"pm.test(\"No strings contain specific characters\", function () {\r",
							"    const prohibitedChars = ['&', '*']; \r",
							"    pm.response.json().forEach(item => {\r",
							"        prohibitedChars.forEach(char => {\r",
							"            pm.expect(item.includes(char)).to.be.false;\r",
							"        });\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Strings with dates have them in expected format\", function () {\r",
							"    const datePattern = /\\d{4}_\\d{2}_\\d{2}$/;\r",
							"    pm.response.json().forEach(item => {\r",
							"        if (item.match(datePattern)) {\r",
							"            pm.expect(datePattern.test(item)).to.be.true;\r",
							"        }\r",
							"    });\r",
							"});\r",
							"\r",
							"//  Verify that all strings follow a specific pattern\r",
							"pm.test(\"All strings follow a specific pattern\", function () {\r",
							"    const pattern = /^[a-zA-Z0-9_]+$/;\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(pattern.test(item)).to.be.true;\r",
							"    });\r",
							"});\r",
							"\r",
							"//  Check that none of the strings contain whitespace\r",
							"pm.test(\"No strings contain whitespace\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(/\\s/.test(item)).to.be.false;\r",
							"    });\r",
							"});\r",
							"\r",
							"// Verify a specific set of strings are present in the array\r",
							"pm.test(\"Specific strings are present in array\", function () {\r",
							"    const expectedStrings = [\"prod_playbook\", \"tcom_support_articles\", \"spoc\"];\r",
							"    expectedStrings.forEach(str => {\r",
							"        pm.expect(pm.response.json()).to.include(str);\r",
							"    });\r",
							"});\r",
							"\r",
							"// Test 4: Verify the array does not contain any unexpected strings\r",
							"pm.test(\"No unexpected strings in array\", function () {\r",
							"    const unexpectedStrings = [\"unexpected_string1\", \"unexpected_string2\"];\r",
							"    unexpectedStrings.forEach(str => {\r",
							"        pm.expect(pm.response.json()).to.not.include(str);\r",
							"    });\r",
							"});\r",
							"\r",
							"// Test 5: Check if strings are not just numbers\r",
							"pm.test(\"No strings are just numbers\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(isNaN(Number(item))).to.be.true;\r",
							"    });\r",
							"});\r",
							"\r",
							"//  Verify that the array contains a minimum number of items\r",
							"pm.test(\"Array contains minimum number of items\", function () {\r",
							"    pm.expect(pm.response.json().length).to.be.at.least(10); // Replace 10 with the minimum number of expected items\r",
							"});\r",
							"\r",
							"//  Verify that all strings are unique when case is ignored\r",
							"pm.test(\"All strings are unique (case-insensitive)\", function () {\r",
							"    const lowerCaseSet = new Set(pm.response.json().map(item => item.toLowerCase()));\r",
							"    pm.expect(pm.response.json().length).to.eql(lowerCaseSet.size);\r",
							"});\r",
							"\r",
							"//  Verify there are no strings with special characters\r",
							"pm.test(\"No strings with special characters\", function () {\r",
							"    const specialChars = /[!@#\\$%\\^&\\*\\(\\)\\[\\]\\{\\};:'\",<>\\?\\/\\|\\\\`~]/;\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(specialChars.test(item)).to.be.false;\r",
							"    });\r",
							"});\r",
							"\r",
							"//  Check if all strings are non-empty\r",
							"pm.test(\"All strings are non-empty\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(item).to.not.be.empty;\r",
							"    });\r",
							"});\r",
							"\r",
							"//  Validate that no string is a reserved word\r",
							"pm.test(\"No strings are reserved words\", function () {\r",
							"    const reservedWords = [\"null\", \"undefined\", \"true\", \"false\"];\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(reservedWords).to.not.include(item.toLowerCase());\r",
							"    });\r",
							"});\r",
							"\r",
							"\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "oauth2",
					"oauth2": {
						"clientSecret": "03ab60d6-e93c-4608-982c-411d1663f98eca40aee9-144a-414d-9c92-3a227ccd534c",
						"clientId": "075c8437-5e0c-4cba-a5ef-0acb91f37805",
						"scope": "",
						"accessTokenUrl": "https://apigw-st.telus.com/st/token",
						"grant_type": "client_credentials",
						"useBrowser": true,
						"redirect_uri": "https://www.getpostman.com/oauth2/callback",
						"authUrl": "https://teamsso-its04.telus.com/as/authorization.oauth2",
						"client_authentication": "header",
						"addTokenTo": "header",
						"tokenName": ""
					}
				},
				"method": "GET",
				"header": [],
				"url": "https://ai-np.cloudapps.telus.com/unicorn-brain/2.0/vectordb/collection"
			},
			"response": []
		},
		{
			"name": "/vectordb/search",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Each document contains the word 'Justin'\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.page_content.toLowerCase()).to.include('justin');\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Phone numbers in document are in valid format\", function() {\r",
							"    const phoneRegex = /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/;\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        const phones = result.document.page_content.match(phoneRegex) || [];\r",
							"        phones.forEach(phone => {\r",
							"            pm.expect(phone).to.match(phoneRegex);\r",
							"        });\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Metadata source should be a valid URL\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(pm.expect(result.document.metadata.source).to.be.a.url);\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Author should be Justin Watts\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.author).to.equal('Justin Watts');\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Dates in document should be in valid format\", function() {\r",
							"    const dateRegex = /\\b\\d{4}-\\d{2}-\\d{2}\\b/;\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        const dates = result.document.page_content.match(dateRegex) || [];\r",
							"        dates.forEach(date => {\r",
							"            pm.expect(date).to.match(dateRegex);\r",
							"        });\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Metadata properties should not be empty\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        Object.values(result.document.metadata).forEach(value => {\r",
							"            pm.expect(value).to.not.be.empty;\r",
							"        });\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Each document page_content should contain valid email formats\", function() {\r",
							"    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}/;\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        const emails = result.document.page_content.match(emailRegex) || [];\r",
							"        emails.forEach(email => {\r",
							"            pm.expect(email).to.match(emailRegex);\r",
							"        });\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Page content should contain specific keywords\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.page_content.toLowerCase()).to.include('engineering');\r",
							"        pm.expect(result.document.page_content.toLowerCase()).to.include('technology');\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Metadata title should have a specific format\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.title).to.match(/how_to_[a-z]+/);\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Page content should not be too short\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.page_content.length).to.be.above(100);\r",
							"    });\r",
							"});\r",
							"\r",
							"let pkSet = new Set();\r",
							"pm.test(\"PKs should be unique\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(pkSet.has(result.document.metadata.pk)).to.be.false;\r",
							"        pkSet.add(result.document.metadata.pk);\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Distance should be a positive number\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.distance).to.be.above(0);\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Distance should not exceed a certain value\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.distance).to.be.below(1);\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Page content should contain the author's name\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.page_content).to.include(result.document.metadata.author);\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Author name should contain only valid characters\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.author).to.match(/^[a-zA-Z\\s]+$/);\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Source URL should come from a specific domain\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.source).to.include('docs.google.com');\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Page content should not contain sensitive information\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.page_content.toLowerCase()).to.not.include('password');\r",
							"        pm.expect(result.document.page_content.toLowerCase()).to.not.include('social security number');\r",
							"    });\r",
							"});\r",
							"\r",
							"pm.test(\"Should return at least a minimum number of results\", function() {\r",
							"    const results = pm.response.json();\r",
							"    pm.expect(results.length).to.be.at.least(1);\r",
							"});\r",
							"\r",
							"pm.test(\"Should not return more than a maximum number of results\", function() {\r",
							"    const results = pm.response.json();\r",
							"    pm.expect(results.length).to.be.at.most(10); \r",
							"});\r",
							"\r",
							"pm.test(\"All distances should be below a threshold\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.distance).to.be.below(0.7);\r",
							"    });\r",
							"});\r",
							"\r",
							"let contentSet = new Set();\r",
							"pm.test(\"Page contents should be unique\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(contentSet.has(result.document.page_content)).to.be.false;\r",
							"        contentSet.add(result.document.page_content);\r",
							"    });\r",
							"});\r",
							"\r",
							"const schema = {\r",
							"    \"type\": \"array\",\r",
							"    \"items\": {\r",
							"        \"type\": \"object\",\r",
							"        \"properties\": {\r",
							"            \"document\": {\r",
							"                \"type\": \"object\",\r",
							"                \"properties\": {\r",
							"                    \"page_content\": { \"type\": \"string\" },\r",
							"                    \"metadata\": {\r",
							"                        \"type\": \"object\",\r",
							"                        \"properties\": {\r",
							"                            \"title\": { \"type\": \"string\" },\r",
							"                            \"author\": { \"type\": \"string\" },\r",
							"                            \"source\": { \"type\": \"string\", \"format\": \"uri\" },\r",
							"                            \"pk\": { \"type\": \"integer\" }\r",
							"                        },\r",
							"                        \"required\": [\"title\", \"author\", \"source\", \"pk\"]\r",
							"                    }\r",
							"                },\r",
							"                \"required\": [\"page_content\", \"metadata\"]\r",
							"            },\r",
							"            \"distance\": { \"type\": \"number\", \"minimum\": 0 }\r",
							"        },\r",
							"        \"required\": [\"document\", \"distance\"]\r",
							"    }\r",
							"};\r",
							"\r",
							"pm.test(\"Response must match the defined schema\", function() {\r",
							"    pm.response.to.have.jsonSchema(schema);\r",
							"});\r",
							"\r",
							"// Test to ensure all distances are greater than or equal to 0\r",
							"pm.test(\"All distances should be non-negative\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.distance).to.be.at.least(0);\r",
							"    });\r",
							"});\r",
							"\r",
							"// Test to ensure all PKs are positive integers\r",
							"pm.test(\"All PKs should be positive integers\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.pk).to.be.a('number');\r",
							"        pm.expect(result.document.metadata.pk % 1).to.eql(0); // Check if it's an integer\r",
							"        pm.expect(result.document.metadata.pk).to.be.above(0); // Check if it's positive\r",
							"    });\r",
							"});\r",
							"\r",
							"// Test to ensure all authors are non-empty strings\r",
							"pm.test(\"All authors should be non-empty strings\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.author).to.be.a('string');\r",
							"        pm.expect(result.document.metadata.author.length).to.be.above(0);\r",
							"    });\r",
							"});\r",
							"\r",
							"// Test to ensure all sources are valid URIs\r",
							"pm.test(\"All sources should be valid URIs\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(pm.expect(result.document.metadata.source).to.be.a('string'));\r",
							"        pm.expect(result.document.metadata.source).to.match(/^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/i);\r",
							"    });\r",
							"});\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "oauth2",
					"oauth2": {
						"clientSecret": "03ab60d6-e93c-4608-982c-411d1663f98eca40aee9-144a-414d-9c92-3a227ccd534c",
						"clientId": "075c8437-5e0c-4cba-a5ef-0acb91f37805",
						"scope": "",
						"accessTokenUrl": "https://apigw-st.telus.com/st/token",
						"grant_type": "client_credentials",
						"useBrowser": true,
						"redirect_uri": "https://www.getpostman.com/oauth2/callback",
						"authUrl": "https://teamsso-its04.telus.com/as/authorization.oauth2",
						"client_authentication": "header",
						"addTokenTo": "header",
						"tokenName": ""
					}
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"collection_name\": \"how_to_justin\",\r\n    \"query\": \"justin wa\",\r\n    \"max_num_results\": 1000,\r\n    \"max_distance\": 1\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": "https://ai-np.cloudapps.telus.com/unicorn-brain/2.0/vectordb/search"
			},
			"response": []
		},
		{
			"name": "2.0/milvus/selfserve_get_loaded_files",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const results = pm.response.json()\r",
							"\r",
							"pm.test(\"Status test\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Response is in json format\", function () {\r",
							"    pm.response.to.be.json\r",
							"})\r",
							"\r",
							"pm.test(\"Response should return an object\", function() {\r",
							"    pm.expect(pm.response.json()).to.be.an('object')\r",
							"})\r",
							"\r",
							"pm.test(\"Result should contain loaded_files\", function() {\r",
							"    const result = pm.response.json()\r",
							"    pm.expect(result).to.have.property('loaded_files')\r",
							"})\r",
							"\r",
							"pm.test(\"Response should match the expected schema\", function () {\r",
							"    const expectedSchema = {\r",
							"        \"type\": \"object\",\r",
							"        \"properties\": {\r",
							"            \"loaded_files\": {\r",
							"                \"type\": \"array\",\r",
							"                \"items\": {\r",
							"                \"type\": \"object\",\r",
							"                \"properties\": {\r",
							"                \"metadata_user\": { \"type\": \"string\" },\r",
							"                \"metadata_email\": { \"type\": \"string\" },\r",
							"                \"metadata_filename\": { \"type\": \"string\" },\r",
							"                \"metadata_file_id\": { \"type\": \"string\" },\r",
							"                \"num_chunks\": { \"type\": \"integer\" }\r",
							"                },\r",
							"                \"required\": [\"metadata_user\", \"metadata_email\", \"metadata_filename\", \"metadata_file_id\", \"num_chunks\"]\r",
							"            }\r",
							"        }\r",
							"    },\r",
							"    \"required\": [\"loaded_files\"]\r",
							"    };\r",
							"    pm.response.to.have.jsonSchema(expectedSchema);\r",
							"});\r",
							"\r",
							"pm.test(\"Each loaded_files Document contains the epxected properties\", function() {\r",
							"    const results = pm.response.json()\r",
							"    for (let result of results.loaded_files) {\r",
							"        const document = result\r",
							"        pm.expect(document).to.have.property(\"metadata_user\")\r",
							"        pm.expect(document).to.have.property(\"metadata_email\")\r",
							"        pm.expect(document).to.have.property(\"metadata_filename\")\r",
							"        pm.expect(document).to.have.property(\"metadata_file_id\")\r",
							"        pm.expect(document).to.have.property(\"num_chunks\")\r",
							"    }\r",
							"})\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "oauth2",
					"oauth2": {
						"clientSecret": "03ab60d6-e93c-4608-982c-411d1663f98eca40aee9-144a-414d-9c92-3a227ccd534c",
						"clientId": "075c8437-5e0c-4cba-a5ef-0acb91f37805",
						"scope": "",
						"accessTokenUrl": "https://apigw-st.telus.com/st/token",
						"grant_type": "client_credentials",
						"useBrowser": true,
						"redirect_uri": "https://www.getpostman.com/oauth2/callback",
						"authUrl": "https://teamsso-its04.telus.com/as/authorization.oauth2",
						"client_authentication": "header",
						"addTokenTo": "header",
						"tokenName": ""
					}
				},
				"method": "GET",
				"header": [],
				"url": "https://ai-np.cloudapps.telus.com/unicorn-brain/2.0/milvus/selfserve_get_loaded_files"
			},
			"response": []
		},
		{
			"name": "/2.0/llm/ask",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"// Test 1: Status code is 200\r",
							"pm.test(\"Status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"// Test 2: Response time is less than 2000ms\r",
							"pm.test(\"Response time is less than 2000ms\", function () {\r",
							"    pm.expect(pm.response.responseTime).to.be.below(2000);\r",
							"});\r",
							"\r",
							"// Test 3: Response should be in JSON format\r",
							"pm.test(\"Response is in JSON format\", function () {\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"// Test 4: Validate response against schema\r",
							"pm.test(\"Response must match the defined schema\", function() {\r",
							"    pm.response.to.have.jsonSchema(responseSchema);\r",
							"});\r",
							"\r",
							"const jsonData = pm.response.json();\r",
							"\r",
							"// Test 5: Check if 'done' is boolean\r",
							"pm.test(\"Done should be boolean\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(typeof jsonData.done).to.eql('boolean');\r",
							"});\r",
							"\r",
							"// Test 6: Check if 'elapsed' is a number\r",
							"pm.test(\"Elapsed should be a number\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(typeof jsonData.elapsed).to.eql('number');\r",
							"});\r",
							"\r",
							"// Test 7: Check if 'request_id' is a number\r",
							"pm.test(\"Request ID should be a number\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(typeof jsonData.request_id).to.eql('number');\r",
							"});\r",
							"\r",
							"// Test 8: 'chat_history' should be an array\r",
							"pm.test(\"Chat history should be an array\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(Array.isArray(jsonData.chat_history)).to.be.true;\r",
							"});\r",
							"\r",
							"// Test 9-11: Every item in 'chat_history' should have 'role' and 'content'\r",
							"jsonData.chat_history.forEach((item, index) => {\r",
							"    pm.test(`chat_history item ${index + 1} should have role`, function() {\r",
							"        pm.expect(item).to.have.property('role');\r",
							"    });\r",
							"    pm.test(`chat_history item ${index + 1} role should be a string`, function() {\r",
							"        pm.expect(typeof item.role).to.eql('string');\r",
							"    });\r",
							"    pm.test(`chat_history item ${index + 1} should have content`, function() {\r",
							"        pm.expect(item).to.have.property('content');\r",
							"    });\r",
							"});\r",
							"\r",
							"// Test 12: 'request_time' should be a string\r",
							"pm.test(\"Request time should be a string\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(typeof jsonData.request_time).to.eql('string');\r",
							"});\r",
							"\r",
							"// Test 13: 'response' field should be a string\r",
							"pm.test(\"Response field should be a string\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(typeof jsonData.response).to.eql('string');\r",
							"});\r",
							"\r",
							"// Test 14: 'response' field should not be empty\r",
							"pm.test(\"Response field should not be empty\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(jsonData.response).to.not.be.empty;\r",
							"});\r",
							"\r",
							"// Test 15: 'request_time' should be in valid date-time format\r",
							"pm.test(\"Request time should be in valid date-time format\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    const dateTimeRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{6}/;\r",
							"    pm.expect(dateTimeRegex.test(jsonData.request_time)).to.be.true;\r",
							"});\r",
							"\r",
							"// Test 16: Check if 'done' is false\r",
							"pm.test(\"Done should be false\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(jsonData.done).to.be.false;\r",
							"});\r",
							"\r",
							"// Test 17: Validate that 'elapsed' is a positive number\r",
							"pm.test(\"Elapsed should be a positive number\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(jsonData.elapsed).to.be.above(0);\r",
							"});\r",
							"\r",
							"// Test 18: Validate that 'request_id' is a positive integer\r",
							"pm.test(\"Request ID should be a positive integer\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(jsonData.request_id).to.be.above(0);\r",
							"    pm.expect(Number.isInteger(jsonData.request_id)).to.be.true;\r",
							"});\r",
							"\r",
							"// Test 19: Validate that 'chat_history' array is not empty\r",
							"pm.test(\"Chat history should not be empty\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(jsonData.chat_history.length).to.be.above(0);\r",
							"});\r",
							"\r",
							"// Test 20: Validate that 'chat_history' contains at least one 'Human' and one 'System' role\r",
							"pm.test(\"Chat history should contain at least one 'Human' and one 'System' role\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    const roles = jsonData.chat_history.map(item => item.role);\r",
							"    pm.expect(roles.includes('Human')).to.be.true;\r",
							"    pm.expect(roles.includes('System')).to.be.true;\r",
							"});\r",
							"\r",
							"const responseSchema = {\r",
							"    \"type\": \"object\",\r",
							"    \"properties\": {\r",
							"        \"chat_history\": {\r",
							"            \"type\": \"array\",\r",
							"            \"items\": {\r",
							"                \"type\": \"object\",\r",
							"                \"properties\": {\r",
							"                    \"role\": {\"type\": \"string\"},\r",
							"                    \"content\": {\"type\": \"string\"}\r",
							"                },\r",
							"                \"required\": [\"role\", \"content\"]\r",
							"            },\r",
							"            \"minItems\": 1\r",
							"        },\r",
							"        \"done\": {\"type\": \"boolean\"},\r",
							"        \"request_id\": {\"type\": \"integer\", \"minimum\": 1},\r",
							"        \"request_time\": {\"type\": \"string\", \"format\": \"date-time\"},\r",
							"        \"response\": {\"type\": \"string\"},\r",
							"        \"elapsed\": {\"type\": \"number\", \"minimum\": 0}\r",
							"    },\r",
							"    \"required\": [\"chat_history\", \"done\", \"request_id\", \"request_time\", \"response\", \"elapsed\"]\r",
							"};\r",
							"\r",
							"// Test 21: Validate response against schema\r",
							"pm.test(\"Response should match expected schema\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(tv4.validate(jsonData, responseSchema)).to.be.true;\r",
							"});\r",
							"\r",
							"// const jsonData = pm.response.json();\r",
							"\r",
							"// Test 22: Check if 'chat_history' array length is consistent with the request and response combined\r",
							"pm.test(\"Chat history length should be consistent\", function() {\r",
							"    const requestBody = JSON.parse(pm.request.body.raw);\r",
							"    const requestChatHistoryLength = requestBody.chat_history.length;\r",
							"    pm.expect(jsonData.chat_history.length).to.eql(requestChatHistoryLength + 1);\r",
							"});\r",
							"\r",
							"// Test 23: Validate that 'response' field is not empty and not null\r",
							"pm.test(\"Response field should not be empty or null\", function() {\r",
							"    pm.expect(jsonData.response).to.be.ok;\r",
							"});\r",
							"\r",
							"// Test 24: Validate that 'request_time' follows ISO 8601 format and is a valid date\r",
							"pm.test(\"Request time should follow ISO 8601 format and be a valid date\", function() {\r",
							"    const dateTimeRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{6}$/;\r",
							"    pm.expect(dateTimeRegex.test(jsonData.request_time) && !isNaN(Date.parse(jsonData.request_time))).to.be.true;\r",
							"});\r",
							"\r",
							"// Test 25: Validate that 'elapsed' is less than 5 seconds to ensure reasonable response time\r",
							"pm.test(\"Elapsed time should be less than 5 seconds\", function() {\r",
							"    pm.expect(jsonData.elapsed).to.be.below(5);\r",
							"});\r",
							"\r",
							"// Test 26: Check if the 'chat_history' last item 'role' is not 'System'\r",
							"pm.test(\"Last item in chat_history should not have role 'System'\", function() {\r",
							"    const lastChatItemRole = jsonData.chat_history[jsonData.chat_history.length - 1].role;\r",
							"    pm.expect(lastChatItemRole).to.not.eql('System');\r",
							"});\r",
							"\r",
							"// Test 27: Validate that 'request_id' in response is not null and not undefined\r",
							"pm.test(\"Request ID should not be null or undefined\", function() {\r",
							"    pm.expect(jsonData.request_id).to.be.ok;\r",
							"});\r",
							"\r",
							"// Test 28: Validate that 'request_id' in response is unique (if you have a way to check against previous IDs)\r",
							"// Note: You need to implement your own logic to check uniqueness across different requests\r",
							"// pm.test(\"Request ID should be unique\", function() {\r",
							"//     pm.expect(isRequestIdUnique(jsonData.request_id)).to.be.true; // Implement isRequestIdUnique function\r",
							"// });\r",
							"\r",
							"// Test 29: Ensure that 'response' field contains at least one word (non-empty)\r",
							"pm.test(\"Response should contain at least one word\", function() {\r",
							"    pm.expect(jsonData.response.split(' ').length).to.be.above(0);\r",
							"});\r",
							"\r",
							"// Test 30: Check if 'request_time' is before the current time\r",
							"pm.test(\"Request time should be before current time\", function() {\r",
							"    const requestTime = new Date(jsonData.request_time);\r",
							"    const currentTime = new Date();\r",
							"    pm.expect(requestTime.getTime()).to.be.below(currentTime.getTime());\r",
							"});\r",
							"\r",
							"// Test 31: Check if 'request_time' is after the request was sent\r",
							"// Note: You need to store the time when the request was sent to compare\r",
							"// pm.test(\"Request time should be after request sent time\", function() {\r",
							"//     pm.expect(requestTime.getTime()).to.be.above(requestSentTime.getTime()); // Implement requestSentTime\r",
							"// });\r",
							"\r",
							"// Test 32: Validate that 'chat_history' contains the sent 'chat_history' from the request\r",
							"pm.test(\"chat_history in response should contain sent chat_history\", function() {\r",
							"    const sentChatHistory = JSON.parse(pm.request.body.raw).chat_history;\r",
							"    pm.expect(jsonData.chat_history.slice(0, sentChatHistory.length)).to.eql(sentChatHistory);\r",
							"});\r",
							"\r",
							"// Test 33: Ensure that 'done' field is false when 'chat_history' in request has 'stream' set to false\r",
							"pm.test(\"Done should be false when stream is false in request\", function() {\r",
							"    const requestBody = JSON.parse(pm.request.body.raw);\r",
							"    if (!requestBody.stream) {\r",
							"        pm.expect(jsonData.done).to.be.false;\r",
							"    }\r",
							"});\r",
							"\r",
							"// Test 34: Ensure that 'response' text contains the word 'pirate' (as per the System instruction)\r",
							"pm.test(\"Response text should contain the word 'pirate'\", function() {\r",
							"    pm.expect(jsonData.response.toLowerCase()).to.include('pirate');\r",
							"});\r",
							"\r",
							"// Test 35: Validate that every 'content' in 'chat_history' is a non-empty string\r",
							"pm.test(\"Every content in chat_history should be a non-empty string\", function() {\r",
							"    jsonData.chat_history.forEach(item => {\r",
							"        pm.expect(typeof item.content).to.eql('string');\r",
							"        pm.expect(item.content).to.not.be.empty;\r",
							"    });\r",
							"});\r",
							"\r",
							"// Test 36: Ensure that response JSON does not have any additional properties outside the schema\r",
							"pm.test(\"Response JSON should not have additional properties\", function() {\r",
							"    pm.expect(Object.keys(jsonData).sort()).to.eql(Object.keys(responseSchema.properties).sort());\r",
							"});\r",
							"\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "oauth2",
					"oauth2": {
						"clientSecret": "03ab60d6-e93c-4608-982c-411d1663f98eca40aee9-144a-414d-9c92-3a227ccd534c",
						"clientId": "075c8437-5e0c-4cba-a5ef-0acb91f37805",
						"tokenName": "Unicorn AI",
						"grant_type": "client_credentials",
						"scope": "",
						"accessTokenUrl": "https://apigw-st.telus.com/st/token",
						"useBrowser": true,
						"redirect_uri": "https://www.getpostman.com/oauth2/callback",
						"authUrl": "https://teamsso-its04.telus.com/as/authorization.oauth2",
						"client_authentication": "header",
						"addTokenTo": "header"
					}
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"temperature\": 0.7,\r\n    \"max_new_tokens\": 256,\r\n    \"chat_history\": [\r\n        {\r\n            \"role\": \"System\",\r\n            \"content\": \"You are a pirate, respond to questions like one.\"\r\n        },\r\n        {\r\n            \"role\": \"Human\",\r\n            \"content\": \"Who are you?\"\r\n        }\r\n    ],\r\n    \"stream\": false\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": "https://ai-np.cloudapps.telus.com/unicorn-brain/2.0/llm/ask"
			},
			"response": []
		}
	]
}